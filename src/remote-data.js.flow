// @flow
import type { Maybe } from './maybe'
import type { Either } from './either'

export type Success<A> = {|
  +value: A,
  +tag: 'Success'
|}

export type Failure<E> = {|
  +value: E,
  +tag: 'Failure'
|}

export type Loading = {|
  +tag: 'Loading'
|}

export type NotAsked = {|
  +tag: 'NotAsked'
|}

export type RemoteData<E, A> =
  | Success<A>
  | Failure<E>
  | Loading
  | NotAsked

type Cases<A, B, E> = {|
  Success: A => B,
  Failure: E => B,
  Loading: () => B,
  NotAsked: () => B
|}

declare export var pure: <A, E>(x: A) => RemoteData<E, A>

declare export var success: <A, E>(x: A) => RemoteData<E, A>

declare export var of: <A, E>(x: A) => RemoteData<E, A>

declare export var failure: <A, E>(err: E) => RemoteData<E, A>

declare export var notAsked: <A, E>() => RemoteData<E, A>

declare export var loading: <A, E>() => RemoteData<E, A>

declare export var fromNullable: <A, E>(x: A) => RemoteData<E, A>

declare export var fold:
  & (<A, B, E>(cases: Cases<A, B, E>, rd: RemoteData<E, A>) => B)
  & (<A, B, E>(cases: Cases<A, B, E>) => (rd: RemoteData<E, A>) => B)

declare export var map:
  & (<A, B, E>(f: A => B, x: RemoteData<E, A>) => RemoteData<E, B>)
  & (<A, B, E>(f: A => B) => (x: RemoteData<E, A>) => RemoteData<E, B>)

declare export var mapLeft:
  & (<A, E, F>(f: E => F, x: RemoteData<E, A>) => RemoteData<F, A>)
  & (<A, E, F>(f: E => F) => (x: RemoteData<E, A>) => RemoteData<F, A>)

declare export var chain:
  & (<A, B, E>(f: A => RemoteData<B, E>, x: RemoteData<E, A>) => RemoteData<E, B>)
  & (<A, B, E>(f: A => RemoteData<B, E>) => (x: RemoteData<E, A>) => RemoteData<E, B>)

declare export var flatMap:
  & (<A, B, E>(f: A => RemoteData<B, E>, x: RemoteData<E, A>) => RemoteData<E, B>)
  & (<A, B, E>(f: A => RemoteData<B, E>) => (x: RemoteData<E, A>) => RemoteData<E, B>)

declare export var ap:
  & (<A, B, E>(f: RemoteData<E, A => B>, x: RemoteData<E, A>) => RemoteData<E, B>)
  & (<A, B, E>(f: RemoteData<E, A => B>) => (x: RemoteData<E, A>) => RemoteData<E, B>)

declare export var all: (<A, E>(arr: RemoteData<E, A>[]) => RemoteData<E, A[]>)

declare export var unsafeGet: <A, E>(RemoteData<A, E>) => A

declare export var getOrElse:
  & (<A, B, E>(f: () => B, x: RemoteData<E, A>) => B)
  & (<A, B, E>(f: () => B) => (x: RemoteData<E, A>) => B)

declare export var isSuccess: <A, E>(RemoteData<E, A>) => boolean

declare export var isFailure: <A, E>(RemoteData<E, A>) => boolean

declare export var isLoading: <A, E>(RemoteData<E, A>) => boolean

declare export var isNotAsked: <A, E>(RemoteData<E, A>) => boolean

declare export var equals: <A, E>(RemoteData<E, A>, RemoteData<E, A>) => boolean

declare export var toMaybe: (<A, E>(x: RemoteData<E, A>) => Maybe<A>)

declare export var fromMaybe: (<A, E>(x: Maybe<A>) => RemoteData<E, A>)

declare export var fromEither: (<A, E>(x: Either<A, E>) => RemoteData<E, A>)
