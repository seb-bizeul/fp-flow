// @flow
export type Right<A> = {|
  +value: A,
  +tag: 'Right'
|}

export type Left<E> = {|
  +value: E,
  +tag: 'Left'
|}

export type Either<E, A> =
  | Left<E>
  | Right<A>

export type Just<A> = {|
  +value: A,
  +tag: 'Just'
|}

export type Nothing = {|
  +tag: 'Nothing'
|}

export type Maybe<A> =
  | Just<A>
  | Nothing

export type Success<A> = {|
  +value: A,
  +tag: 'Success'
|}

export type Failure<E> = {|
  +value: E,
  +tag: 'Failure'
|}

export type Loading = {|
  +tag: 'Loading'
|}

export type NotAsked = {|
  +tag: 'NotAsked'
|}

export type RemoteData<A, E> =
  | Success<A>
  | Failure<E>
  | Loading
  | NotAsked

type Cases<A, B, E> = {|
  Success: A => B,
  Failure: E => B,
  Loading: () => B,
  NotAsked: () => B
|}


declare export var either: {
  pure: <E, A>(x: A) => Either<E, A>,
  right: <E, A>(x: A) => Either<E, A>,
  of: <E, A>(x: A) => Either<E, A>,
  left: <E, A>(x: E) => Either<E, A>,
  tryCatch: <E, A>(l: any => E, x: any => A) => Either<E, A>,
  fromNullable: <E, A>(x: A) => Either<E, A>,
  fromMaybe: <E, A>(x: Maybe<A>) => Either<E, A>,
  toMaybe: <E, A>(x: Either<E, A>) => Maybe<A>,
  map:
    & (<E, A, B>(f: (A => B), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: (A => B)) => (x: Either<E, A>) => Either<E, B>),
  mapLeft:
    & (<E, F, A>(f: (E => F), x: Either<E, A>) => Either<F, A>)
    & (<E, F, A>(f: (E => F)) => (x: Either<E, A>) => Either<F, A>),
  bimap:
    & (<E, F, A, B>(l: (E => F), r: (A => B), x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(l: E => F, r: A => B) => (x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(l: E => F) => (r: A => B, x: Either<E, A>) => Either<F, B>),
  chain:
    & (<E, A, B>(f: (A => Either<E, B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: A => Either<E, B>) => (x: Either<E, A>) => Either<E, B>),
  flatMap:
    & (<E, A, B>(f: (A => Either<E, B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: A => Either<E, B>) => (x: Either<E, A>) => Either<E, B>),
  bind:
    & (<E, A, B>(f: (A => Either<E, B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: A => Either<E, B>) => (x: Either<E, A>) => Either<E, B>),
  ap:
    & (<E, A, B>(f: (Either<E, A => B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: Either<E, A => B>) => (x: Either<E, A>) => Either<E, B>),
  fold:
    & (<E, F, A, B>(left: (E => F), right: (A => B), x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(left: E => F, right: A => B) => (x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(left: E => F) => (right: (A => B), x: Either<E, A>) => Either<F, B>),
  unsafeGet: <E, A>(x: Either<E, A>) => A,
  getOrElse:
    & (<E, A>(f: (E) => A, x: Either<E, A>) => A)
    & (<E, A>(f: (E) => A) => (x: Either<E, A>) => A),
  isLeft: <E, A>(x: Either<E, A>) => boolean,
  isRight: <E, A>(x: Either<E, A>) => boolean,
  equals: <E, A>(x: Either<E, A>, y: Either<E, A>) => boolean
}

declare export var maybe: {
  pure: <A>(x: A) => Maybe<A>,
  just: <A>(x: A) => Maybe<A>,
  of: <A>(x: A) => Maybe<A>,
  nothing: <A>() => Maybe<A>,
  fromNullable: <A>(x: A) => Maybe<A>,
  map:
    & (<A, B>(f: (A => B), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => B) => (x: Maybe<A>) => Maybe<B>),
  map2:
    & (<A, B>(f: (A => B), m1: Maybe<A>, m2: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>, m2: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>) => (m2: Maybe<A>) => Maybe<B>[]),
  map3:
    & (<A, B>(f: (A => B), m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>, m2: Maybe<A>) => (m3: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>) => (m2: Maybe<A>, m3: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>) => Maybe<B>[]),
  map4:
    & (<A, B>(f: (A => B), m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>) => (m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>, m2: Maybe<A>) => (m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>) => (m2: Maybe<A>, m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[]),
  chain:
    & (<A, B>(f: (A => Maybe<B>), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => Maybe<B>) => (x: Maybe<A>) => Maybe<B>),
  flatMap:
    & (<A, B>(f: (A => Maybe<B>), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => Maybe<B>) => (x: Maybe<A>) => Maybe<B>),
  bind:
    & (<A, B>(f: (A => Maybe<B>), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => Maybe<B>) => (x: Maybe<A>) => Maybe<B>),
  ap:
    & (<A, B>(f: Maybe<A => B>, x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: Maybe<A => B>) => (x: Maybe<A>) => Maybe<B>),
  fold:
    & (<A, B>(n: () => B, j: A => B, x: Maybe<A>) => Maybe<B>)
    & (<A, B>(n: () => B, j: A => B) => (x: Maybe<A>) => Maybe<B>)
    & (<A, B>(n: () => B) => (j: A => B) => (x: Maybe<A>) => Maybe<B>),
  unsafeGet: <A>(x: Maybe<A>) => A,
  getOrElse:
    & (<A>(f: () => A, x: Maybe<A>) => A)
    & (<A>(f: () => A) => (x: Maybe<A>) => A),
  isJust: <A>(x: Maybe<A>) => boolean,
  isNothing: <A>(x: Maybe<A>) => boolean,
  equals: <A>(x: Maybe<A>, y: Maybe<A>) => boolean
}

declare export var remoteData: {
  pure: <A, E>(x: A) => RemoteData<A, E>,
  success: <A, E>(x: A) => RemoteData<A, E>,
  of: <A, E>(x: A) => RemoteData<A, E>,
  failure: <A, E>(err: E) => RemoteData<A, E>,
  notAsked: <A, E>() => RemoteData<A, E>,
  loading: <A, E>() => RemoteData<A, E>,
  fromNullable: <A, E>(x: A) => RemoteData<A, E>,
  fold:
    & (<A, B, E>(cases: Cases<A, B, E>, rd: RemoteData<A, E>) => B)
    & (<A, B, E>(cases: Cases<A, B, E>) => (rd: RemoteData<A, E>) => B),
  map:
    & (<A, B, E>(f: A => B, x: RemoteData<A, E>) => RemoteData<B, E>)
    & (<A, B, E>(f: A => B) => (x: RemoteData<A, E>) => RemoteData<B, E>),
  mapLeft:
    & (<A, E, F>(f: E => F, x: RemoteData<A, E>) => RemoteData<A, F>)
    & (<A, E, F>(f: E => F) => (x: RemoteData<A, E>) => RemoteData<A, F>),
  chain:
    & (<A, B, E>(f: A => RemoteData<B, E>, x: RemoteData<A, E>) => RemoteData<B, E>)
    & (<A, B, E>(f: A => RemoteData<B, E>) => (x: RemoteData<A, E>) => RemoteData<B, E>),
  flatMap:
    & (<A, B, E>(f: A => RemoteData<B, E>, x: RemoteData<A, E>) => RemoteData<B, E>)
    & (<A, B, E>(f: A => RemoteData<B, E>) => (x: RemoteData<A, E>) => RemoteData<B, E>),
  ap:
    & (<A, B, E>(f: RemoteData<A, E> => B, x: RemoteData<A, E>) => RemoteData<B, E>)
    & (<A, B, E>(f: RemoteData<A, E> => B) => (x: RemoteData<A, E>) => RemoteData<B, E>),
  unsafeGet: <A, E>(RemoteData<A, E>) => A,
  getOrElse:
    & (<A, B, E>(f: () => B, x: RemoteData<A, E>) => B)
    & (<A, B, E>(f: () => B) => (x: RemoteData<A, E>) => B),
  isSuccess: <A, E>(RemoteData<A, E>) => boolean,
  isFailure: <A, E>(RemoteData<A, E>) => boolean,
  isLoading: <A, E>(RemoteData<A, E>) => boolean,
  isNotAsked: <A, E>(RemoteData<A, E>) => boolean,
  toMaybe: (<A, E>(x: RemoteData<A, E>) => Maybe<A>),
  fromMaybe: (<A, E>(fallback: E, x: Maybe<A>) => RemoteData<A, E>),
  fromEither: (<A, E>(x: Either<A, E>) => RemoteData<A, E>)
}
