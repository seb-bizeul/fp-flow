// @flow
export type Right<A> = {|
  +value: A,
  +tag: 'Right'
|}

export type Left<E> = {|
  +value: E,
  +tag: 'Left'
|}

export type Either<E, A> =
  | Left<E>
  | Right<A>

export type Just<A> = {|
  +value: A,
  +tag: 'Just'
|}

export type Nothing = {|
  +tag: 'Nothing'
|}

export type Maybe<A> =
  | Just<A>
  | Nothing

export type Success<A> = {|
  +value: A,
  +tag: 'Success'
|}

export type Failure<E> = {|
  +value: E,
  +tag: 'Failure'
|}

export type Loading = {|
  +tag: 'Loading'
|}

export type NotAsked = {|
  +tag: 'NotAsked'
|}

export type RemoteData<E, A> =
  | Success<A>
  | Failure<E>
  | Loading
  | NotAsked

type Cases<A, B, E> = {|
  Success: A => B,
  Failure: E => B,
  Loading: () => B,
  NotAsked: () => B
|}


declare export var either: {
  pure: <E, A>(x: A) => Either<E, A>,
  right: <E, A>(x: A) => Either<E, A>,
  of: <E, A>(x: A) => Either<E, A>,
  left: <E, A>(x: E) => Either<E, A>,
  tryCatch: <E, A>(l: any => E, x: any => A) => Either<E, A>,
  fromNullable: <E, A>(x: A) => Either<E, A>,
  fromMaybe: <E, A>(x: Maybe<A>) => Either<E, A>,
  toMaybe: <E, A>(x: Either<E, A>) => Maybe<A>,
  map:
    & (<E, A, B>(f: (A => B), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: (A => B)) => (x: Either<E, A>) => Either<E, B>),
  mapLeft:
    & (<E, F, A>(f: (E => F), x: Either<E, A>) => Either<F, A>)
    & (<E, F, A>(f: (E => F)) => (x: Either<E, A>) => Either<F, A>),
  bimap:
    & (<E, F, A, B>(l: (E => F), r: (A => B), x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(l: E => F, r: A => B) => (x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(l: E => F) => (r: A => B, x: Either<E, A>) => Either<F, B>),
  chain:
    & (<E, A, B>(f: (A => Either<E, B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: A => Either<E, B>) => (x: Either<E, A>) => Either<E, B>),
  flatMap:
    & (<E, A, B>(f: (A => Either<E, B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: A => Either<E, B>) => (x: Either<E, A>) => Either<E, B>),
  bind:
    & (<E, A, B>(f: (A => Either<E, B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: A => Either<E, B>) => (x: Either<E, A>) => Either<E, B>),
  ap:
    & (<E, A, B>(f: (Either<E, A => B>), x: Either<E, A>) => Either<E, B>)
    & (<E, A, B>(f: Either<E, A => B>) => (x: Either<E, A>) => Either<E, B>),
  fold:
    & (<E, F, A, B>(left: (E => F), right: (A => B), x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(left: E => F, right: A => B) => (x: Either<E, A>) => Either<F, B>)
    & (<E, F, A, B>(left: E => F) => (right: (A => B), x: Either<E, A>) => Either<F, B>),
  unsafeGet: <E, A>(x: Either<E, A>) => A,
  getOrElse:
    & (<E, A>(f: (E) => A, x: Either<E, A>) => A)
    & (<E, A>(f: (E) => A) => (x: Either<E, A>) => A),
  isLeft: <E, A>(x: Either<E, A>) => boolean,
  isRight: <E, A>(x: Either<E, A>) => boolean,
  equals: <E, A>(x: Either<E, A>, y: Either<E, A>) => boolean
}

declare export var maybe: {
  pure: <A>(x: A) => Maybe<A>,
  just: <A>(x: A) => Maybe<A>,
  of: <A>(x: A) => Maybe<A>,
  nothing: <A>() => Maybe<A>,
  fromNullable: <A>(x: A) => Maybe<A>,
  map:
    & (<A, B>(f: (A => B), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => B) => (x: Maybe<A>) => Maybe<B>),
  map2:
    & (<A, B>(f: (A => B), m1: Maybe<A>, m2: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>, m2: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>) => (m2: Maybe<A>) => Maybe<B>[]),
  map3:
    & (<A, B>(f: (A => B), m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>, m2: Maybe<A>) => (m3: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>) => (m2: Maybe<A>, m3: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>) => Maybe<B>[]),
  map4:
    & (<A, B>(f: (A => B), m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>) => (m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>, m2: Maybe<A>) => (m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B, m1: Maybe<A>) => (m2: Maybe<A>, m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[])
    & (<A, B>(f: (A) => B) => (m1: Maybe<A>, m2: Maybe<A>, m3: Maybe<A>, m4: Maybe<A>) => Maybe<B>[]),
  chain:
    & (<A, B>(f: (A => Maybe<B>), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => Maybe<B>) => (x: Maybe<A>) => Maybe<B>),
  flatMap:
    & (<A, B>(f: (A => Maybe<B>), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => Maybe<B>) => (x: Maybe<A>) => Maybe<B>),
  bind:
    & (<A, B>(f: (A => Maybe<B>), x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: (A) => Maybe<B>) => (x: Maybe<A>) => Maybe<B>),
  ap:
    & (<A, B>(f: Maybe<A => B>, x: Maybe<A>) => Maybe<B>)
    & (<A, B>(f: Maybe<A => B>) => (x: Maybe<A>) => Maybe<B>),
  fold:
    & (<A, B>(n: () => B, j: A => B, x: Maybe<A>) => Maybe<B>)
    & (<A, B>(n: () => B, j: A => B) => (x: Maybe<A>) => Maybe<B>)
    & (<A, B>(n: () => B) => (j: A => B) => (x: Maybe<A>) => Maybe<B>),
  unsafeGet: <A>(x: Maybe<A>) => A,
  getOrElse:
    & (<A>(f: () => A, x: Maybe<A>) => A)
    & (<A>(f: () => A) => (x: Maybe<A>) => A),
  isJust: <A>(x: Maybe<A>) => boolean,
  isNothing: <A>(x: Maybe<A>) => boolean,
  equals: <A>(x: Maybe<A>, y: Maybe<A>) => boolean
}

declare export var remoteData: {
  pure: <A, E>(x: A) => RemoteData<E, A>,
  success: <A, E>(x: A) => RemoteData<E, A>,
  of: <A, E>(x: A) => RemoteData<E, A>,
  failure: <A, E>(err: E) => RemoteData<E, A>,
  notAsked: <A, E>() => RemoteData<E, A>,
  loading: <A, E>() => RemoteData<E, A>,
  fromNullable: <A, E>(x: A) => RemoteData<E, A>,
  fold:
    & (<A, B, E>(cases: Cases<A, B, E>, rd: RemoteData<E, A>) => B)
    & (<A, B, E>(cases: Cases<A, B, E>) => (rd: RemoteData<E, A>) => B),
  map:
    & (<A, B, E>(f: A => B, x: RemoteData<E, A>) => RemoteData<E, B>)
    & (<A, B, E>(f: A => B) => (x: RemoteData<E, A>) => RemoteData<E, B>),
  mapLeft:
    & (<A, E, F>(f: E => F, x: RemoteData<E, A>) => RemoteData<F, A>)
    & (<A, E, F>(f: E => F) => (x: RemoteData<E, A>) => RemoteData<F, A>),
  chain:
    & (<A, B, E>(f: A => RemoteData<E, B>, x: RemoteData<E, A>) => RemoteData<E, B>)
    & (<A, B, E>(f: A => RemoteData<E, B>) => (x: RemoteData<E, A>) => RemoteData<E, B>),
  flatMap:
    & (<A, B, E>(f: A => RemoteData<E, B>, x: RemoteData<E, A>) => RemoteData<B, E>)
    & (<A, B, E>(f: A => RemoteData<E, B>) => (x: RemoteData<E, A>) => RemoteData<B, E>),
  ap:
    & (<A, B, E>(f: RemoteData<E, A => B>, x: RemoteData<E, A>) => RemoteData<E, B>)
    & (<A, B, E>(f: RemoteData<E, A => B>) => (x: RemoteData<E, A>) => RemoteData<E, B>),
  unsafeGet: <A, E>(RemoteData<E, A>) => A,
  getOrElse:
    & (<A, B, E>(f: () => B, x: RemoteData<E, A>) => B)
    & (<A, B, E>(f: () => B) => (x: RemoteData<E, A>) => B),
  isSuccess: <A, E>(RemoteData<E, A>) => boolean,
  isFailure: <A, E>(RemoteData<E, A>) => boolean,
  isLoading: <A, E>(RemoteData<E, A>) => boolean,
  isNotAsked: <A, E>(RemoteData<E, A>) => boolean,
  toMaybe: (<A, E>(x: RemoteData<E, A>) => Maybe<A>),
  fromMaybe: (<A, E>(x: Maybe<A>) => RemoteData<E, A>),
  fromEither: (<A, E>(x: Either<A, E>) => RemoteData<E, A>)
}

declare export var pipe:
  & (<A, B>(f1: A => B) => (A) => B)
  & (<A, B, C>(f1: A => B, f2: B => C) => (A) => C)
  & (<A, B, C, D>(f1: A => B, f2: B => C, f3: C => D) => (A) => D)
  & (<A, B, C, D, E>(f1: A => B, f2: B => C, f3: C => D, f4: D => E) => (A) => E)
  & (<A, B, C, D, E, F>(f1: A => B, f2: B => C, f3: C => D, f4: D => E, f5: E => F) => (A) => F)
  & (<A, B, C, D, E, F, G>(f1: A => B, f2: B => C, f3: C => D, f4: D => E, f5: E => F, f6: F => G) => (A) => G)
  & (<A, B, C, D, E, F, G, H>(f1: A => B, f2: B => C, f3: C => D, f4: D => E, f5: E => F, f6: F => G, f7: G => H) => (A) => H)
  & (<A, B, C, D, E, F, G, H, I>(f1: A => B, f2: B => C, f3: C => D, f4: D => E, f5: E => F, f6: F => G, f7: G => H, f8: H => I) => (A) => I)
  & (<A, B, C, D, E, F, G, H, I, J>(f1: A => B, f2: B => C, f3: C => D, f4: D => E, f5: E => F, f6: F => G, f7: G => H, f8: H => I, f9: I => J) => (A) => J)
  & (<A, B, C, D, E, F, G, H, I, J, K>(f1: A => B, f2: B => C, f3: C => D, f4: D => E, f5: E => F, f6: F => G, f7: G => H, f8: H => I, f9: I => J, f10: J => K) => (A) => K)

declare export var compose:
  & (<A, B>(f1: A => B) => (A) => B)
  & (<A, B, C>(f1: B => C, f2: A => B) => (A) => C)
  & (<A, B, C, D>(f1: C => D, f2: B => C, f3: A => B) => (A) => D)
  & (<A, B, C, D, E>(f1: D => E, f2: C => D, f3: B => C, f4: A => B) => (A) => E)
  & (<A, B, C, D, E, F>(f1: E => F, f2: D => E, f3: C => D, f4: B => C, f5: A => B) => (A) => F)
  & (<A, B, C, D, E, F, G>(f1: F => G, f2: E => F, f3: D => E, f4: C => D, f5: B => C, f6: A => B) => (A) => G)
  & (<A, B, C, D, E, F, G, H>(f1: G => H, f2: F => G, f3: E => F, f4: D => E, f5: C => D, f6: B => C, f7: A => B) => (A) => H)
  & (<A, B, C, D, E, F, G, H, I>(f1: H => I, f2: G => H, f3: F => G, f4: E => F, f5: D => E, f6: C => D, f7: B => C, f8: A => B) => (A) => I)
  & (<A, B, C, D, E, F, G, H, I, J>(f1: I => J, f2: H => I, f3: G => H, f4: F => G, f5: E => F, f6: D => E, f7: C => D, f8: B => C, f9: A => B) => (A) => J)
  & (<A, B, C, D, E, F, G, H, I, J, K>(f1: J => K, f2: I => J, f3: H => I, f4: G => H, f5: F => G, f6: E => F, f7: D => E, f8: C => D, f9: B => C, f10: A => B) => (A) => K)
